# lecture06_solutions.py  Solutions to lecture 6 workshop problems

# 1. Write a function called onetrial() that takes no input arguments, and simulates
# a single trial of an experiment. The function returns a tuple with the following
# elements.
#      element 0: stimulus level, randomly chosen from the following values:
#                 -1.0, -0.9, 0.8, ..., 1.0
#      element 1: 0 or 1 indicating a correct or incorrect response; this is a
#                 Bernoulli random variable with probability of success
#                 scipy.stats.norm.cdf(s, loc=0, scale=0.5), where s is the
#                 stimulus level that you chose for element 0
#      element 2: response time, equal to 0.1 + 0.1*(1-c) + np.random.normal()**2,
#                 where c is the 0 or 1 that you created for element 1; that is,
#                 incorrect trials have slightly longer response times

import numpy as np
import scipy

def onetrial():
    stimlevs = np.linspace(-1, 1, 21)
    s = np.random.choice(stimlevs)
    p = scipy.stats.norm.cdf(s, loc=0, scale=0.5)
    c = np.random.binomial(1, p)
    rt = 0.1 + 0.1*(1-c) * np.random.normal()**2
    return s, c, rt

# 2. Use a list comprehension to generate a list of 500 tuples, where each tuple
# is generated by a call to onetrial() from problem 1.

data = [onetrial() for t in range(500)]

# 3. Modify your solution to problem 2 so that the trial number (1-500) is
# the first element of each tuple. For example, the first tuple might look like
# this: (1, -0.9, 1, 0.245). For this problem, don't take the list produced in
# problem 2 and modify it. Instead, modify the code for problem 2 so that it
# generates a list of these new tuples.

data = [(t+1,) + onetrial() for t in range(500)]

# 4. Use np.array() to convert the result of problem 3 to a numpy array. Find the
# mean and standard deviation of the response times.

data = np.array(data)
rt = data[:,3]
rt_mu = rt.mean()
rt_sigma = rt.std()

# 5. Plot a histogram of the response times. Format the plot (axis labels, etc.)
# so that it looks like one you could include in a research paper.

import matplotlib.pyplot as plt

plt.hist(rt, bins=np.linspace(0, 0.8, 20))
plt.xlim(0, 0.85)
plt.xlabel('response time (seconds)')
plt.ylabel('frequency')
plt.show()
